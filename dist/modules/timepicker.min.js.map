{"version":3,"sources":["timepicker.min.js","timepicker/timepicker.js"],"names":["angular","module","provider","defaults","this","animation","prefixClass","placement","template","trigger","container","keyboard","html","delay","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","Infinity","maxTime","length","hourStep","minuteStep","roundDisplay","iconUp","iconDown","arrowBehavior","$get","$window","$document","$rootScope","$sce","$dateFormatter","$tooltip","$timeout","timepickerFactory","element","controller","config","floorMinutes","time","coeff","options","Date","Math","floor","getTime","createSelection","start","end","createTextRange","selRange","collapse","moveStart","moveEnd","select","setSelectionRange","isUndefined","selectionStart","selectionEnd","focusElement","focus","$timepicker","extend","parentScope","scope","$options","$scope","lang","formatDate","date","format","selectedIndex","defaultDate","startDate","$dateValue","viewDate","hour","getHours","meridian","minute","getMinutes","second","getSeconds","millisecond","getMilliseconds","getDatetimeFormat","hoursFormat","timeSeparator","minutesFormat","showAM","$iconUp","$iconDown","$select","index","$moveIndex","value","$switchMeridian","switchMeridian","update","isDate","isNaN","$date","$build","$isBuilt","keep","setHours","setMinutes","$setViewValue","copy","$render","hide","hours","i","midIndex","parseInt","push","label","selected","$isSelected","disabled","$isDisabled","minutes","rows","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","$onMouseDown","evt","target","nodeName","toLowerCase","preventDefault","stopPropagation","isTouch","targetEl","parent","triggerHandler","$onKeyDown","test","keyCode","shiftKey","altKey","hoursLength","minutesLength","lateralMove","count","selectRange","$digest","_init","init","isNative","prop","css","attr","on","_destroy","destroy","off","_show","show","$element","_hide","blur","$isShown","document","body","navigator","userAgent","getDefaultLocale","directive","$parse","$q","$dateParser","requestAnimationFrame","setTimeout","restrict","require","link","validateAgainstMinMaxTime","parsedTime","isMinValid","setFullYear","isMaxValid","isValid","$setValidity","getTimeFormattedString","forEach","key","isDefined","falseValueRegExp","bsShow","$watch","newValue","oldValue","timepicker","isString","match","dateParser","$observe","getTimeForAttribute","ngModel","$parsers","unshift","viewValue","parse","timezoneOffsetAdjust","toISOString","$formatters","modelValue","NaN","val","$on"],"mappings":"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","file":"timepicker.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.2.1 - 2015-11-27\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = [\"$window\", \"$document\", \"$rootScope\", \"$sce\", \"$dateFormatter\", \"$tooltip\", \"$timeout\", function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    }];\n\n  })\n\n\n  .directive('bsTimepicker', [\"$window\", \"$parse\", \"$q\", \"$dateFormatter\", \"$dateParser\", \"$timepicker\", function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  }]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}