{"version":3,"sources":["tooltip.min.js","tooltip/tooltip.js"],"names":["angular","module","provider","defaults","this","animation","customClass","prefixClass","prefixEvent","container","target","placement","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","viewport","selector","padding","$get","$window","$rootScope","$compile","$q","$templateCache","$http","$animate","$sce","dimensions","$$rAF","$timeout","TooltipFactory","element","config","enterAnimateCallback","scope","$emit","options","$tooltip","leaveAnimateCallback","tipElement","_tipToHide","_blur","blur","destroyTipElement","bindTriggerEvents","triggers","split","forEach","on","toggle","enter","leave","nodeName","isTouch","$onFocusElementMouseDown","unbindTriggerEvents","i","length","off","bindKeyboardEvents","$onKeyUp","$onFocusKeyUp","unbindKeyboardEvents","bindAutoCloseEvents","stopEventPropagation","$body","hide","_autoCloseEventsBinded","unbindAutoCloseEvents","event","stopPropagation","getPosition","$element","el","isBody","tagName","elRect","getBoundingClientRect","rect","p","width","extend","right","left","height","bottom","top","elOffset","offset","scroll","document","documentElement","scrollTop","body","prop","outerDims","clientWidth","innerHeight","getCalculatedOffset","position","actualWidth","actualHeight","applyPlacement","tip","offsetWidth","offsetHeight","marginTop","parseInt","css","marginLeft","isNaN","setOffset","using","props","Math","round","test","delta","getViewportAdjustedDelta","isVertical","arrowDelta","arrowOffsetPosition","replaceArrow","$viewport","findElement","viewportPadding","viewportDimensions","topEdgeOffset","bottomEdgeOffset","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","clearTimeout","timeout","$isShown","tipScope","$destroy","remove","toLowerCase","$options","$promise","fetchTemplate","$scope","$new","isString","map","parseFloat","$id","id","attr","trustAsHtml","$setEnabled","isEnabled","$$postDigest","setEnabled","$hide","$show","$toggle","hoverState","then","templateEl","contentEl","removeAttr","outerHTML","tipLinker","tipTemplate","tipContainer","isObject","data","replace","htmlReplaceRegExp","trim","apply","init","isNumber","isElement","focus","destroy","setTimeout","parent","after","lastChild","clonedElement","display","visibility","addClass","prepend","safeDigest","$applyPlacement","promise","setViewport","autoToken","autoPlace","elementPosition","tipWidth","tipHeight","originalPlacement","containerPosition","indexOf","removeClass","tipPosition","evt","which","preventDefault","$$phase","$root","$digest","query","querySelectorAll","fetchPromises","get","cache","res","String","prototype","directive","$location","restrict","link","transclusion","key","isDefined","hasOwnProperty","$observe","newValue","oldValue","tooltip","bsTooltip","$watch","bsShow","match","$on"],"mappings":"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","file":"tooltip.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.2.1 - 2015-11-27\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$compile\", \"$q\", \"$templateCache\", \"$http\", \"$animate\", \"$sce\", \"dimensions\", \"$$rAF\", \"$timeout\", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    }];\n\n  })\n\n  .directive('bsTooltip', [\"$window\", \"$location\", \"$sce\", \"$tooltip\", \"$$rAF\", function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  }]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}