{"version":3,"sources":["typeahead.min.js","typeahead/typeahead.js"],"names":["angular","module","provider","defaults","this","animation","prefixClass","prefixEvent","placement","template","trigger","container","keyboard","html","delay","minLength","filter","limit","autoSelect","comparator","$get","$window","$rootScope","$tooltip","$timeout","TypeaheadFactory","element","controller","config","$typeahead","options","extend","parentScope","scope","$scope","$resetMatches","$matches","$activeIndex","$activate","index","$$postDigest","activate","$select","evt","select","$isVisible","update","matches","length","test","$applyPlacement","value","$setViewValue","$render","$digest","$emit","isString","$viewValue","$getIndex","l","i","$onMouseDown","preventDefault","stopPropagation","$onKeyDown","keyCode","isUndefined","show","$element","on","hide","off","document","body","directive","$parse","$q","$parseOptions","restrict","require","link","attr","forEach","key","isDefined","bsOptions","parsedOptions","typeahead","watchOptions","watchedOptions","$match","replace","trim","$watch","newValue","oldValue","valuesFn","then","values","ngModel","$modelValue","selectMode","substring","slice","isVisible","$formatters","push","modelValue","displayValue","undefined","$isEmpty","val","selected","label","isObject","toString","$on","destroy"],"mappings":"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","file":"typeahead.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.2.1 - 2015-11-27\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$tooltip\", \"$timeout\", function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    }];\n\n  })\n\n  .directive('bsTypeahead', [\"$window\", \"$parse\", \"$q\", \"$typeahead\", \"$parseOptions\", function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  }]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}