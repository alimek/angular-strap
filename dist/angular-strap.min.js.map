{"version":3,"sources":["angular-strap.min.js","module.js","affix/affix.js","alert/alert.js","aside/aside.js","button/button.js","collapse/collapse.js","datepicker/datepicker.js","dropdown/dropdown.js","helpers/date-formatter.js","helpers/date-parser.js","helpers/debounce.js","helpers/dimensions.js","helpers/parse-options.js","helpers/raf.js","modal/modal.js","navbar/navbar.js","popover/popover.js","scrollspy/scrollspy.js","select/select.js","tab/tab.js","timepicker/timepicker.js","tooltip/tooltip.js","typeahead/typeahead.js"],"names":["window","document","undefined","angular","module","provider","defaults","this","offsetTop","inlineStyles","$get","$window","debounce","dimensions","AffixFactory","element","config","getRequiredAffixClass","unpin","position","elementHeight","scrollTop","getScrollTop","scrollHeight","getScrollHeight","top","offsetBottom","initialAffixTop","targetEl","pageYOffset","body","$affix","options","extend","target","reset","setWidth","initialOffsetTop","affixed","parent","offsetParent","match","i","init","$parseOffsets","offset","style","width","on","checkPosition","checkPositionWithEventLoop","windowEl","$debouncedOnResize","destroy","off","setTimeout","height","affix","removeClass","addClass","css","offsetUnpin","bodyEl","offsetHeight","offsetWidth","$onResize","initialPosition","directive","restrict","require","link","scope","attr","affixTarget","$element","forEach","key","isDefined","option","test","$on","controller","animation","prefixClass","prefixEvent","placement","template","container","backdrop","keyboard","show","duration","type","dismissable","$modal","$timeout","AlertFactory","$alert","$scope","hide","$sce","requestAnimationFrame","transclusion","hasOwnProperty","title","$observe","newValue","oldValue","trustAsHtml","bsAlert","$watch","isObject","content","alert","trigger","toggle","contentTemplate","html","AsideFactory","$aside","bsAside","aside","activeClass","toggleEvent","compile","removeAttr","children","querySelectorAll","child","childEl","ngModel","$button","$$rAF","constantValueRegExp","isInput","nodeName","activeElement","trueValue","$eval","falseValue","hasExoticValues","$parsers","push","viewValue","$formatters","modelValue","equals","$render","isActive","$modelValue","checked","toggleClass","bind","$apply","$setViewValue","hasClass","value","v","disallowToggle","startCollapsed","allowMultiple","$attrs","fixActiveItemIndexes","index","activeIndexes","self","$targets","$active","length","activeItems","indexOf","deactivateItem","splice","activateItem","$options","copy","$toggles","$viewChangeListeners","$registerToggle","$registerTarget","$unregisterToggle","$unregisterTarget","fn","$setActive","isArray","$activeIndexes","$collapse","$animate","attrs","controllers","ngModelCtrl","bsCollapseCtrl","bsCollapseToggle","render","active","action","delay","useNative","dateType","dateFormat","timezone","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","autoclose","minDate","Infinity","maxDate","startView","minView","startWeek","daysOfWeekDisabled","iconLeft","iconRight","$document","$rootScope","$dateFormatter","datepickerViews","$tooltip","DatepickerFactory","updateSelected","el","selected","$datepicker","$isSelected","date","focusElement","focus","parentScope","pickerViews","$views","views","viewDate","$mode","$iconLeft","$iconRight","$picker","$select","select","$selectPane","$toggleMode","setMode","update","isDate","isNaN","getTime","$date","call","$build","updateDisabledDates","dateRanges","disabledDateRanges","l","rows","$setDisabledEl","keep","$dateValue","Date","year","getFullYear","month","getMonth","getDate","mode","pristine","built","build","$updateSelected","isSelected","disabled","isDisabled","steps","targetDate","UTC","getUTCFullYear","getUTCMonth","getUTCDate","$onMouseDown","evt","preventDefault","stopPropagation","isTouch","toLowerCase","triggerHandler","$onKeyDown","keyCode","shiftKey","altKey","onKeyDown","$digest","_init","isNative","prop","_destroy","_show","$isShown","_hide","blur","navigator","userAgent","lang","getDefaultLocale","$parse","$q","$dateParser","normalizeDateRanges","ranges","validateAgainstMinMaxDate","parsedDate","isMinValid","datepicker","isMaxValid","isValid","$setValidity","getDateFormattedString","formatDate","bsShow","isString","format","dateParser","strict","getDateForAttribute","disabledDates","disabledRanges","previousValue","unshift","parse","$viewValue","timezoneOffsetAdjust","toISOString","isUndefined","NaN","val","split","arr","size","arrays","mod","n","m","daySplit","picker","weekDaysMin","weekdaysShort","weekDaysLabels","slice","concat","weekDaysLabelsHtml","join","startDate","force","firstDayOfMonth","firstDayOfMonthOffset","getTimezoneOffset","firstDate","getDay","firstDateOffset","today","toDateString","day","days","daylightSavingAdjust","isToday","label","muted","showLabels","labels","time","setHours","setMinutes","setSeconds","setMilliseconds","start","end","newDate","actualTime","name","months","lastDate","actualMonth","setMonth","parseInt","firstYear","years","actualYear","setYear","Array","prototype","DropdownFactory","onBodyClick","$dropdown","$new","parentEl","items","matchesSelector","eq","Element","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","bsDropdown","dropdown","service","$locale","dateFilter","splitTimeFormat","exec","id","getDatetimeFormat","DATETIME_FORMATS","SHORTDAY","hoursFormat","timeFormat","minutesFormat","timeSeparator","showAM","$localeProvider","ParseDate","hours","minutes","seconds","milliseconds","noop","isNumeric","parseFloat","isFinite","indexOfCaseInsensitive","array","len","str","toString","getHours","setDate","setFullYear","fromDate","getMinutes","getSeconds","getMilliseconds","toDate","proto","DateParserFactory","setMapForFormat","keys","Object","setFnMap","map","sortedMap","clonedFormat","search","escapeReservedSymbols","text","replace","regExpForFormat","regExpMap","re","RegExp","regex","setMap","sss","ss","s","mm","HH","H","hh","h","a","EEEE","DAY","EEE","dd","d","MMMM","MONTH","MMM","SHORTMONTH","MM","M","yyyy","yy","y","$format","baseDate","formatRegex","formatSetMap","matches","substr","getTimeForAttribute","undo","factory","func","wait","immediate","timeout","context","args","arguments","callNow","cancel","apply","leading","trailing","extra","currentStyle","getComputedStyle","boxRect","getBoundingClientRect","docElement","ownerDocument","documentElement","clientTop","left","pageXOffset","scrollLeft","clientLeft","setOffset","curPosition","curLeft","curCSSTop","curTop","curOffset","curCSSLeft","calculatePosition","curElem","props","isFunction","using","offsetParentElement","offsetParentRect","outer","regexp","ParseOptionsFactory","parseValues","values","locals","valueName","displayFn","valueFn","$parseOptions","$values","keyName","groupByFn","valuesFn","$match","when","then","displayValue","version","minor","dot","webkitRequestAnimationFrame","mozRequestAnimationFrame","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","webkitCancelRequestAnimationFrame","rafSupported","raf","timer","supported","backdropAnimation","$compile","$templateCache","$http","ModalFactory","enterAnimateCallback","$emit","leaveAnimateCallback","bodyElement","hideOnBackdropClick","currentTarget","preventEventDefault","$promise","fetchTemplate","$id","$hide","$$postDigest","$show","$toggle","templateEl","contentEl","findElement","next","remove","outerHTML","modalLinker","modalElement","backdropElement","bottom","right","z-index","data","htmlReplaceRegExp","trim","$destroy","after","isElement","lastChild","clonedElement","defaultPrevented","display","enter","promise","safeDigest","$onKeyUp","leave","which","$$phase","$root","query","fetchPromises","get","cache","res","String","falseValueRegExp","bsModal","modal","routeAttr","$location","$navbar","path","liElements","li","liElement","pattern","customClass","autoClose","PopoverFactory","$popover","popover","$applyPlacement","bsPopover","viewport","setViewport","spies","$$spies","throttle","ScrollSpyFactory","isWindowSpy","scrollEl","scrollId","$$count","unbindViewContentLoaded","unbindIncludeContentLoaded","activeTarget","debouncedCheckPosition","throttledCheckPosition","debouncedCheckOffsets","viewportHeight","$scrollspy","trackedElements","$trackedElements","sortedElements","checkOffsets","Math","max","innerHeight","docEl","$activateElement","$getTrackedElement","source","filter","obj","trackedElement","targetElement","querySelector","sort","b","trackElement","untrackElement","toDelete","activate","scrollspy","multiple","allNoneButtons","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$matches","$activeIndex","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$noneText","$activate","$isVisible","$isActive","$selectAll","$selectNone","$updateActiveIndex","$getIndex","minLength","inputEl","parsedOptions","bsOptions","watchedOptions","$isEmpty","navClass","$navClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$remove","activeIndex","$tab","transclude","templateUrl","bsTabsCtrl","console","warn","bsActivePane","parsedBsActivePane","assign","timeType","modelTimeFormat","minTime","maxTime","hourStep","minuteStep","roundDisplay","iconUp","iconDown","arrowBehavior","timepickerFactory","floorMinutes","coeff","floor","createSelection","createTextRange","selRange","collapse","moveStart","moveEnd","setSelectionRange","selectionStart","selectionEnd","$timepicker","selectedIndex","defaultDate","hour","meridian","minute","second","millisecond","$iconUp","$iconDown","$moveIndex","$switchMeridian","switchMeridian","$isBuilt","midIndex","$isDisabled","isAM","selectedTime","$arrowAction","$setTimeByStep","hoursLength","minutesLength","lateralMove","count","selectRange","validateAgainstMinMaxTime","parsedTime","getTimeFormattedString","timepicker","bsEnabled","selector","padding","TooltipFactory","tipElement","_tipToHide","_blur","destroyTipElement","bindTriggerEvents","triggers","$onFocusElementMouseDown","unbindTriggerEvents","bindKeyboardEvents","$onFocusKeyUp","unbindKeyboardEvents","bindAutoCloseEvents","stopEventPropagation","$body","_autoCloseEventsBinded","unbindAutoCloseEvents","event","getPosition","isBody","tagName","elRect","rect","p","elOffset","scroll","outerDims","clientWidth","getCalculatedOffset","actualWidth","actualHeight","applyPlacement","tip","marginTop","marginLeft","round","delta","getViewportAdjustedDelta","isVertical","arrowDelta","arrowOffsetPosition","replaceArrow","$viewport","viewportPadding","viewportDimensions","topEdgeOffset","bottomEdgeOffset","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","clearTimeout","tipScope","$setEnabled","isEnabled","setEnabled","hoverState","tipLinker","tipTemplate","tipContainer","isNumber","visibility","prepend","autoToken","autoPlace","elementPosition","tipWidth","tipHeight","originalPlacement","containerPosition","tipPosition","tooltip","bsTooltip","limit","autoSelect","comparator","TypeaheadFactory","$typeahead","$resetMatches","typeahead","watchOptions","selectMode","substring","isVisible"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.2.1 - 2015-11-27\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function(window, document, undefined) {\n'use strict';\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n\n// Source: affix.js\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = [\"$window\", \"debounce\", \"dimensions\", function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    }];\n\n  })\n\n  .directive('bsAffix', [\"$affix\", \"$window\", function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  }])\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: [\"$element\", function($element) {\n        this.$element = $element;\n      }]\n    };\n  });\n\n// Source: alert.js\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      template: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = [\"$modal\", \"$timeout\", function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    }];\n\n  })\n\n  .directive('bsAlert', [\"$window\", \"$sce\", \"$alert\", function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: aside.js\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      template: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = [\"$modal\", function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    }];\n\n  })\n\n  .directive('bsAside', [\"$window\", \"$sce\", \"$aside\", function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: button.js\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', [\"$button\", \"$$rAF\", function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  }])\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', [\"$button\", \"$$rAF\", function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  }]);\n\n// Source: collapse.js\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = angular.copy(value);\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', [\"$window\", \"$animate\", \"$collapse\", function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  }])\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', [\"$animate\", function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  }]);\n\n// Source: datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      template: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = [\"$window\", \"$document\", \"$rootScope\", \"$sce\", \"$dateFormatter\", \"datepickerViews\", \"$tooltip\", \"$timeout\", function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    }];\n\n  })\n\n  .directive('bsDatepicker', [\"$window\", \"$parse\", \"$q\", \"$dateFormatter\", \"$dateParser\", \"$datepicker\", function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$viewValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  }])\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = [\"$dateFormatter\", \"$dateParser\", \"$sce\", function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date) {\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n                var maxDate = new Date(options.maxDate),\n                    minDate = new Date(options.minDate);\n\n                minDate.setHours(0);\n                minDate.setMinutes(0);\n                minDate.setSeconds(0);\n                minDate.setMilliseconds(0);\n                maxDate.setHours(0);\n                maxDate.setMinutes(0);\n                maxDate.setSeconds(0);\n                maxDate.setMilliseconds(0);\n\n                options.minDate = minDate.getTime();\n                options.maxDate = maxDate.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    }];\n\n  });\n\n// Source: dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      template: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$tooltip\", \"$timeout\", function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    }];\n\n  })\n\n  .directive('bsDropdown', [\"$window\", \"$sce\", \"$dropdown\", function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', [\"$locale\", \"dateFilter\", function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[3];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  }]);\n\n// Source: date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', [\"$localeProvider\", function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = [\"$locale\", \"dateFilter\", function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  }];\n\n}]);\n\n// Source: debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', [\"$timeout\", function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n}])\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', [\"$timeout\", function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n}]);\n\n// Source: dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', [\"$document\", \"$window\", function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  }]);\n\n// Source: parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = [\"$parse\", \"$q\", function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            $parseOptions.$values = values ? parseValues(values, scope) : {};\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    }];\n\n  });\n\n// Source: raf.js\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', [\"$window\", \"$timeout\", function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n}]);\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n\n// Source: modal.js\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      template: 'modal/modal.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$compile\", \"$q\", \"$templateCache\", \"$http\", \"$animate\", \"$timeout\", \"$sce\", \"dimensions\", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        $modal.$promise = fetchTemplate(options.template);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $modal.$promise = $modal.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(contentTemplate);\n              // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n              if(!config.template) contentEl.next().remove();\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize modal\n        var modalLinker, modalElement;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        $modal.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          modalLinker = $compile(template);\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = null;\n          }\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // Fetch a cloned element linked from template\n          modalElement = $modal.$element = modalLinker(scope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          var promise = $animate.leave(modalElement, leaveAnimateCallback);\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        // Private methods\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return ModalFactory;\n\n    }];\n\n  })\n\n  .directive('bsModal', [\"$window\", \"$sce\", \"$modal\", function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['keyboard', 'html'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        if(angular.isDefined(attr.backdrop)) {\n          options.backdrop = falseValueRegExp.test(attr.backdrop) ? false : attr.backdrop;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: navbar.js\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', [\"$window\", \"$location\", \"$navbar\", function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  }]);\n\n// Source: popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      container: false,\n      target: false,\n      placement: 'right',\n      template: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = [\"$tooltip\", function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    }];\n\n  })\n\n  .directive('bsPopover', [\"$window\", \"$sce\", \"$popover\", function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass', 'autoClose', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n        \n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: scrollspy.js\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = [\"$window\", \"$document\", \"$rootScope\", \"dimensions\", \"debounce\", \"throttle\", function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    }];\n\n  })\n\n  .directive('bsScrollspy', [\"$rootScope\", \"debounce\", \"dimensions\", \"$scrollspy\", function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  }])\n\n\n  .directive('bsScrollspyList', [\"$rootScope\", \"debounce\", \"dimensions\", \"$scrollspy\", function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  }]);\n\n// Source: select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      template: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = [\"$window\", \"$document\", \"$rootScope\", \"$tooltip\", \"$timeout\", function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        // parse sort option value to support attribute as string\n        // when binded to interpolated value\n        options.sort = options.sort.toString().match(/true|1/i);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        scope.$activeIndex = -1;\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort();\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          } \n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    }];\n\n  })\n\n  .directive('bsSelect', [\"$window\", \"$parse\", \"$q\", \"$select\", \"$parseOptions\", function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'placeholder', 'multiple', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: tab.js\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // DEPRECATED: $viewChangeListeners, please use $activePaneChangeListeners\n      // Because we deprecated ngModel usage, we rename viewChangeListeners to \n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var activeIndex = self.$panes.$active;\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to \n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        self.$setActive(activeIndex);\n      };\n\n      self.$panes.$active = 0;\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', [\"$window\", \"$animate\", \"$tab\", \"$parse\", function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // DEPRECATED: ngModel, please use bsActivePane\n        // 'ngModel' is deprecated bacause if interferes with form validation\n        // and status, so avoid using it here.\n        if(ngModelCtrl) {\n          console.warn('Usage of ngModel is deprecated, please use bsActivePane instead!');\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue * 1);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue * 1);\n          }, true);\n        }\n      }\n    };\n\n  }])\n\n  .directive('bsPane', [\"$window\", \"$animate\", \"$sce\", function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          var active = bsTabsCtrl.$panes.$active;\n          $animate[index === active ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  }]);\n\n// Source: timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = [\"$window\", \"$document\", \"$rootScope\", \"$sce\", \"$dateFormatter\", \"$tooltip\", \"$timeout\", function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    }];\n\n  })\n\n\n  .directive('bsTimepicker', [\"$window\", \"$parse\", \"$q\", \"$dateFormatter\", \"$dateParser\", \"$timepicker\", function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$compile\", \"$q\", \"$templateCache\", \"$http\", \"$animate\", \"$sce\", \"dimensions\", \"$$rAF\", \"$timeout\", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    }];\n\n  })\n\n  .directive('bsTooltip', [\"$window\", \"$location\", \"$sce\", \"$tooltip\", \"$$rAF\", function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  }]);\n\n// Source: typeahead.js\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = [\"$window\", \"$rootScope\", \"$tooltip\", \"$timeout\", function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    }];\n\n  })\n\n  .directive('bsTypeahead', [\"$window\", \"$parse\", \"$q\", \"$typeahead\", \"$parseOptions\", function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  }]);\n\n})(window, document);\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.aside',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.button',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.navbar',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.typeahead',\n  'mgcrea.ngStrap.scrollspy',\n  'mgcrea.ngStrap.affix',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.collapse'\n]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n// @TODO: submit issue to core\n// '<span ng-if=\"title\"><strong ng-bind=\"title\"></strong>&nbsp;</span><span ng-bind-html=\"content\"></span>' +\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      template: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissable: true\n    };\n\n    this.$get = function($modal, $timeout) {\n\n      function AlertFactory(config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissable]\n        $alert.$scope.dismissable = !!options.dismissable;\n        if(options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if(options.duration) {\n          $alert.show = function() {\n            show();\n            $timeout(function() {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function($window, $sce, $alert) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissable'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAlert && scope.$watch(attr.bsAlert, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.aside', ['mgcrea.ngStrap.modal'])\n\n  .provider('$aside', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade-and-slide-right',\n      prefixClass: 'aside',\n      prefixEvent: 'aside',\n      placement: 'right',\n      template: 'aside/aside.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($modal) {\n\n      function AsideFactory(config) {\n\n        var $aside = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $aside = $modal(options);\n\n        return $aside;\n\n      }\n\n      return AsideFactory;\n\n    };\n\n  })\n\n  .directive('bsAside', function($window, $sce, $aside) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsAside && scope.$watch(attr.bsAside, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize aside\n        var aside = $aside(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', aside.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (aside) aside.destroy();\n          options = null;\n          aside = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.button', [])\n\n  .provider('$button', function() {\n\n    var defaults = this.defaults = {\n      activeClass:'active',\n      toggleEvent:'click'\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsCheckboxGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"checkbox\"]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.attr('bs-checkbox', '');\n          childEl.attr('ng-model', attr.ngModel + '.' + childEl.attr('value'));\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsCheckbox', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support label > input[type=\"checkbox\"]\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var trueValue = angular.isDefined(attr.trueValue) ? attr.trueValue : true;\n        if(constantValueRegExp.test(attr.trueValue)) {\n          trueValue = scope.$eval(attr.trueValue);\n        }\n        var falseValue = angular.isDefined(attr.falseValue) ? attr.falseValue : false;\n        if(constantValueRegExp.test(attr.falseValue)) {\n          falseValue = scope.$eval(attr.falseValue);\n        }\n\n        // Parse exotic values\n        var hasExoticValues = typeof trueValue !== 'boolean' || typeof falseValue !== 'boolean';\n        if(hasExoticValues) {\n          controller.$parsers.push(function(viewValue) {\n            // console.warn('$parser', element.attr('ng-model'), 'viewValue', viewValue);\n            return viewValue ? trueValue : falseValue;\n          });\n          // modelValue -> $formatters -> viewValue\n          controller.$formatters.push(function(modelValue) {\n             // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n             return angular.equals(modelValue, trueValue);\n          });\n          // Fix rendering for exotic values\n          scope.$watch(attr.ngModel, function(newValue, oldValue) {\n            controller.$render();\n          });\n        }\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, trueValue);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('ng-model'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            if(!isInput) {\n              controller.$setViewValue(!activeElement.hasClass('active'));\n            }\n            if(!hasExoticValues) {\n              controller.$render();\n            }\n          });\n        });\n\n      }\n\n    };\n\n  })\n\n  .directive('bsRadioGroup', function() {\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      compile: function postLink(element, attr) {\n        element.attr('data-toggle', 'buttons');\n        element.removeAttr('ng-model');\n        var children = element[0].querySelectorAll('input[type=\"radio\"]');\n        angular.forEach(children, function(child) {\n          angular.element(child).attr('bs-radio', '');\n          angular.element(child).attr('ng-model', attr.ngModel);\n        });\n      }\n\n    };\n\n  })\n\n  .directive('bsRadio', function($button, $$rAF) {\n\n    var defaults = $button.defaults;\n    var constantValueRegExp = /^(true|false|\\d+)$/;\n\n    return {\n      restrict: 'A',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        var options = defaults;\n\n        // Support `label > input[type=\"radio\"]` markup\n        var isInput = element[0].nodeName === 'INPUT';\n        var activeElement = isInput ? element.parent() : element;\n\n        var value;\n        attr.$observe('value', function(v) {\n          value = constantValueRegExp.test(v) ? scope.$eval(v) : v;\n          controller.$render();\n        });\n\n        // model -> view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('value'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var isActive = angular.equals(controller.$modelValue, value);\n          $$rAF(function() {\n            if(isInput) element[0].checked = isActive;\n            activeElement.toggleClass(options.activeClass, isActive);\n          });\n        };\n\n        // view -> model\n        element.bind(options.toggleEvent, function() {\n          scope.$apply(function () {\n            // console.warn('!click', element.attr('value'), 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue, 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue);\n            controller.$setViewValue(value);\n            controller.$render();\n          });\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.collapse', [])\n\n  .provider('$collapse', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-collapse',\n      disallowToggle: false,\n      activeClass: 'in',\n      startCollapsed: false,\n      allowMultiple: false\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'disallowToggle', 'activeClass', 'startCollapsed', 'allowMultiple'], function (key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      self.$toggles = [];\n      self.$targets = [];\n\n      self.$viewChangeListeners = [];\n\n      self.$registerToggle = function(element) {\n        self.$toggles.push(element);\n      };\n      self.$registerTarget = function(element) {\n        self.$targets.push(element);\n      };\n\n      self.$unregisterToggle = function(element) {\n        var index = self.$toggles.indexOf(element);\n        // remove toggle from $toggles array\n        self.$toggles.splice(index, 1);\n      };\n      self.$unregisterTarget = function(element) {\n        var index = self.$targets.indexOf(element);\n\n        // remove element from $targets array\n        self.$targets.splice(index, 1);\n\n        if (self.$options.allowMultiple) {\n          // remove target index from $active array values\n          deactivateItem(element);\n        }\n\n        // fix active item indexes\n        fixActiveItemIndexes(index);\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      // use array to store all the currently open panels\n      self.$targets.$active = !self.$options.startCollapsed ? [0] : [];\n      self.$setActive = $scope.$setActive = function(value) {\n        if(angular.isArray(value)) {\n          self.$targets.$active = angular.copy(value);\n        }\n        else if(!self.$options.disallowToggle) {\n          // toogle element active status\n          isActive(value) ? deactivateItem(value) : activateItem(value);\n        } else {\n          activateItem(value);\n        }\n\n        self.$viewChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n      self.$activeIndexes = function() {\n        return self.$options.allowMultiple ? self.$targets.$active :\n          self.$targets.$active.length === 1 ? self.$targets.$active[0] : -1;\n      };\n\n      function fixActiveItemIndexes(index) {\n        // item with index was removed, so we\n        // need to adjust other items index values\n        var activeIndexes = self.$targets.$active;\n        for(var i = 0; i < activeIndexes.length; i++) {\n          if (index < activeIndexes[i]) {\n            activeIndexes[i] = activeIndexes[i] - 1;\n          }\n\n          // the last item is active, so we need to\n          // adjust its index\n          if (activeIndexes[i] === self.$targets.length) {\n            activeIndexes[i] = self.$targets.length - 1;\n          }\n        }\n      }\n\n      function isActive(value) {\n        var activeItems = self.$targets.$active;\n        return activeItems.indexOf(value) === -1 ? false : true;\n      }\n\n      function deactivateItem(value) {\n        var index = self.$targets.$active.indexOf(value);\n        if (index !== -1) {\n          self.$targets.$active.splice(index, 1);\n        }\n      }\n\n      function activateItem(value) {\n        if (!self.$options.allowMultiple) {\n          // remove current selected item\n          self.$targets.$active.splice(0, 1);\n        }\n\n        if (self.$targets.$active.indexOf(value) === -1) {\n          self.$targets.$active.push(value);\n        }\n      }\n\n    };\n\n    this.$get = function() {\n      var $collapse = {};\n      $collapse.defaults = defaults;\n      $collapse.controller = controller;\n      return $collapse;\n    };\n\n  })\n\n  .directive('bsCollapse', function($window, $animate, $collapse) {\n\n    var defaults = $collapse.defaults;\n\n    return {\n      require: ['?ngModel', 'bsCollapse'],\n      controller: ['$scope', '$element', '$attrs', $collapse.controller],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        if(ngModelCtrl) {\n\n          // Update the modelValue following\n          bsCollapseCtrl.$viewChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsCollapseCtrl.$activeIndexes());\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            if (angular.isArray(modelValue)) {\n              // model value is an array, so just replace\n              // the active items directly\n              bsCollapseCtrl.$setActive(modelValue);\n            }\n            else {\n              var activeIndexes = bsCollapseCtrl.$activeIndexes();\n\n              if (angular.isArray(activeIndexes)) {\n                // we have an array of selected indexes\n                if (activeIndexes.indexOf(modelValue * 1) === -1) {\n                  // item with modelValue index is not active\n                  bsCollapseCtrl.$setActive(modelValue * 1);\n                }\n              }\n              else if (activeIndexes !== modelValue * 1) {\n                bsCollapseCtrl.$setActive(modelValue * 1);\n              }\n            }\n            return modelValue;\n          });\n\n        }\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseToggle', function() {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base attr\n        element.attr('data-toggle', 'collapse');\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerToggle(element);\n\n        // remove toggle from collapse controller when toggle is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterToggle(element);\n        });\n\n        element.on('click', function() {\n          var index = attrs.bsCollapseToggle || bsCollapseCtrl.$toggles.indexOf(element);\n          bsCollapseCtrl.$setActive(index * 1);\n          scope.$apply();\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsCollapseTarget', function($animate) {\n\n    return {\n      require: ['^?ngModel', '^bsCollapse'],\n      // scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsCollapseCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('collapse');\n\n        // Add animation class\n        if(bsCollapseCtrl.$options.animation) {\n          element.addClass(bsCollapseCtrl.$options.animation);\n        }\n\n        // Push pane to parent bsCollapse controller\n        bsCollapseCtrl.$registerTarget(element);\n\n        // remove pane target from collapse controller when target is destroyed\n        scope.$on('$destroy', function() {\n          bsCollapseCtrl.$unregisterTarget(element);\n        });\n\n        function render() {\n          var index = bsCollapseCtrl.$targets.indexOf(element);\n          var active = bsCollapseCtrl.$activeIndexes();\n          var action = 'removeClass';\n          if (angular.isArray(active)) {\n            if (active.indexOf(index) !== -1) {\n              action = 'addClass';\n            }\n          }\n          else if (index === active) {\n            action = 'addClass';\n          }\n\n          $animate[action](element, bsCollapseCtrl.$options.activeClass);\n        }\n\n        bsCollapseCtrl.$viewChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$datepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'datepicker',\n      placement: 'bottom-left',\n      template: 'datepicker/datepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: false,\n      dateType: 'date',\n      dateFormat: 'shortDate',\n      timezone: null,\n      modelDateFormat: null,\n      dayFormat: 'dd',\n      monthFormat: 'MMM',\n      yearFormat: 'yyyy',\n      monthTitleFormat: 'MMMM yyyy',\n      yearTitleFormat: 'yyyy',\n      strictFormat: false,\n      autoclose: false,\n      minDate: -Infinity,\n      maxDate: +Infinity,\n      startView: 0,\n      minView: 0,\n      startWeek: 0,\n      daysOfWeekDisabled: '',\n      iconLeft: 'glyphicon glyphicon-chevron-left',\n      iconRight: 'glyphicon glyphicon-chevron-right'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function DatepickerFactory(element, controller, config) {\n\n        var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $datepicker.$options;\n        var scope = $datepicker.$scope;\n        if(options.startView) options.startView -= options.minView;\n\n        // View vars\n\n        var pickerViews = datepickerViews($datepicker);\n        $datepicker.$views = pickerViews.views;\n        var viewDate = pickerViews.viewDate;\n        scope.$mode = options.startView;\n        scope.$iconLeft = options.iconLeft;\n        scope.$iconRight = options.iconRight;\n        var $picker = $datepicker.$views[scope.$mode];\n\n        // Scope methods\n\n        scope.$select = function(date) {\n          $datepicker.select(date);\n        };\n        scope.$selectPane = function(value) {\n          $datepicker.$selectPane(value);\n        };\n        scope.$toggleMode = function() {\n          $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n        };\n\n        // Public methods\n\n        $datepicker.update = function(date) {\n          // console.warn('$datepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $datepicker.$date = date;\n            $picker.update.call($picker, date);\n          }\n          // Build only if pristine\n          $datepicker.$build(true);\n        };\n\n        $datepicker.updateDisabledDates = function(dateRanges) {\n          options.disabledDateRanges = dateRanges;\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n          }\n        };\n\n        $datepicker.select = function(date, keep) {\n          // console.warn('$datepicker.select', date, scope.$mode);\n          if(!angular.isDate(controller.$dateValue)) controller.$dateValue = new Date(date);\n          if(!scope.$mode || keep) {\n            controller.$setViewValue(angular.copy(date));\n            controller.$render();\n            if(options.autoclose && !keep) {\n              $timeout(function() { $datepicker.hide(true); });\n            }\n          } else {\n            angular.extend(viewDate, {year: date.getFullYear(), month: date.getMonth(), date: date.getDate()});\n            $datepicker.setMode(scope.$mode - 1);\n            $datepicker.$build();\n          }\n        };\n\n        $datepicker.setMode = function(mode) {\n          // console.warn('$datepicker.setMode', mode);\n          scope.$mode = mode;\n          $picker = $datepicker.$views[scope.$mode];\n          $datepicker.$build();\n        };\n\n        // Protected methods\n\n        $datepicker.$build = function(pristine) {\n          // console.warn('$datepicker.$build() viewDate=%o', viewDate);\n          if(pristine === true && $picker.built) return;\n          if(pristine === false && !$picker.built) return;\n          $picker.build.call($picker);\n        };\n\n        $datepicker.$updateSelected = function() {\n          for(var i = 0, l = scope.rows.length; i < l; i++) {\n            angular.forEach(scope.rows[i], updateSelected);\n          }\n        };\n\n        $datepicker.$isSelected = function(date) {\n          return $picker.isSelected(date);\n        };\n\n        $datepicker.$setDisabledEl = function(el) {\n          el.disabled = $picker.isDisabled(el.date);\n        };\n\n        $datepicker.$selectPane = function(value) {\n          var steps = $picker.steps;\n          // set targetDate to first day of month to avoid problems with\n          // date values rollover. This assumes the viewDate does not\n          // depend on the day of the month\n          var targetDate = new Date(Date.UTC(viewDate.year + ((steps.year || 0) * value), viewDate.month + ((steps.month || 0) * value), 1));\n          angular.extend(viewDate, {year: targetDate.getUTCFullYear(), month: targetDate.getUTCMonth(), date: targetDate.getUTCDate()});\n          $datepicker.$build();\n        };\n\n        $datepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $datepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          if(evt.keyCode === 13) {\n            if(!scope.$mode) {\n              return $datepicker.hide(true);\n            } else {\n              return scope.$apply(function() { $datepicker.setMode(scope.$mode - 1); });\n            }\n          }\n\n          // Navigate with keyboard\n          $picker.onKeyDown(evt);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function updateSelected(el) {\n          el.selected = $datepicker.$isSelected(el.date);\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $datepicker.init;\n        $datepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'date');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $datepicker.destroy;\n        $datepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $datepicker.show;\n        $datepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // if $datepicker is no longer showing, don't setup events\n            if(!$datepicker.$isShown) return;\n            $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $datepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $datepicker.hide;\n        $datepicker.hide = function(blur) {\n          if(!$datepicker.$isShown) return;\n          $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $datepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $datepicker;\n\n      }\n\n      DatepickerFactory.defaults = defaults;\n      return DatepickerFactory;\n\n    };\n\n  })\n\n  .directive('bsDatepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n\n    var defaults = $datepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!datepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          newValue === true ? datepicker.show() : datepicker.hide();\n        });\n\n        // Initialize datepicker\n        var datepicker = $datepicker(element, controller, options);\n        options = datepicker.$options;\n        // Set expected iOS format\n        if(isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n\n        var lang = options.lang;\n\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        // Observe attributes for changes\n        angular.forEach(['minDate', 'maxDate'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            // console.warn('attr.$observe(%s)=%o', key, newValue);\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            // Build only if dirty\n            !isNaN(datepicker.$options[key]) && datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          datepicker.update(controller.$dateValue);\n        }, true);\n\n        // Normalize undefined/null/empty array,\n        // so that we don't treat changing from undefined->null as a change.\n        function normalizeDateRanges(ranges) {\n          if (!ranges || !ranges.length) return null;\n          return ranges;\n        }\n\n        if (angular.isDefined(attr.disabledDates)) {\n          scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n            disabledRanges = normalizeDateRanges(disabledRanges);\n            previousValue = normalizeDateRanges(previousValue);\n\n            if (disabledRanges) {\n              datepicker.updateDisabledDates(disabledRanges);\n            }\n          });\n        }\n\n        function validateAgainstMinMaxDate(parsedDate) {\n          if (!angular.isDate(parsedDate)) return;\n          var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n          var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(isValid) controller.$dateValue = parsedDate;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            controller.$setValidity('date', true);\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            return null;\n          }\n          var parsedDate = dateParser.parse(viewValue, controller.$viewValue);\n          if(!parsedDate || isNaN(parsedDate.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxDate(parsedDate);\n          }\n\n          if(options.dateType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n            return formatDate(date, options.modelDateFormat || options.dateFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.dateType === 'number') {\n            return date.getTime();\n          } else if(options.dateType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.dateType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.dateType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelDateFormat);\n          } else if(options.dateType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) {\n          //   var today = new Date();\n          //   date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);\n          // }\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getDateFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getDateFormattedString());\n        };\n\n        function getDateFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(datepicker) datepicker.destroy();\n          options = null;\n          datepicker = null;\n        });\n\n      }\n    };\n\n  })\n\n  .provider('datepickerViews', function() {\n\n    var defaults = this.defaults = {\n      dayFormat: 'dd',\n      daySplit: 7\n    };\n\n    // Split array into smaller arrays\n    function split(arr, size) {\n      var arrays = [];\n      while(arr.length > 0) {\n        arrays.push(arr.splice(0, size));\n      }\n      return arrays;\n    }\n\n    // Modulus operator\n    function mod(n, m) {\n      return ((n % m) + m) % m;\n    }\n\n    this.$get = function($dateFormatter, $dateParser, $sce) {\n\n      return function(picker) {\n\n        var scope = picker.$scope;\n        var options = picker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format) {\n          return $dateFormatter.formatDate(date, format, lang);\n        };\n        var dateParser = $dateParser({format: options.dateFormat, lang: lang, strict: options.strictFormat});\n\n        var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n        var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n        var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n\n        var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n        var viewDate = {year: startDate.getFullYear(), month: startDate.getMonth(), date: startDate.getDate()};\n\n        var views = [{\n            format: options.dayFormat,\n            split: 7,\n            steps: { month: 1 },\n            update: function(date, force) {\n              if(!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getDate() !== viewDate.date) {\n                viewDate.date = picker.$date.getDate();\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1), firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n              var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5), firstDateOffset = firstDate.getTimezoneOffset();\n              var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n              // Handle daylight time switch\n              if(firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 60e3);\n              var days = [], day;\n              for(var i = 0; i < 42; i++) { // < 7 * 6\n                day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n                days.push({date: day, isToday: day.toDateString() === today, label: formatDate(day, this.format), selected: picker.$date && this.isSelected(day), muted: day.getMonth() !== viewDate.month, disabled: this.isDisabled(day)});\n              }\n              scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n              scope.showLabels = true;\n              scope.labels = weekDaysLabelsHtml;\n              scope.rows = split(days, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n            },\n            isDisabled: function(date) {\n              var time = date.getTime();\n\n                var maxDate = new Date(options.maxDate),\n                    minDate = new Date(options.minDate);\n\n                minDate.setHours(0);\n                minDate.setMinutes(0);\n                minDate.setSeconds(0);\n                minDate.setMilliseconds(0);\n                maxDate.setHours(0);\n                maxDate.setMinutes(0);\n                maxDate.setSeconds(0);\n                maxDate.setMilliseconds(0);\n\n                options.minDate = minDate.getTime();\n                options.maxDate = maxDate.getTime();\n\n              // Disabled because of min/max date.\n              if (time < options.minDate || time > options.maxDate) return true;\n\n              // Disabled due to being a disabled day of the week\n              if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n\n              // Disabled because of disabled date range.\n              if (options.disabledDateRanges) {\n                for (var i = 0; i < options.disabledDateRanges.length; i++) {\n                  if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                    return true;\n                  }\n                }\n              }\n\n              return false;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualTime = picker.$date.getTime();\n              var newDate;\n\n              if(evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5);\n              else if(evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5);\n              else if(evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5);\n              else if(evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'month',\n            format: options.monthFormat,\n            split: 4,\n            steps: { year: 1 },\n            update: function(date, force) {\n              if(!this.built || date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getMonth() !== viewDate.month) {\n                angular.extend(viewDate, {month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstMonth = new Date(viewDate.year, 0, 1);\n              var months = [], month;\n              for (var i = 0; i < 12; i++) {\n                month = new Date(viewDate.year, i, 1);\n                months.push({date: month, label: formatDate(month, this.format), selected: picker.$isSelected(month), disabled: this.isDisabled(month)});\n              }\n              scope.title = formatDate(month, options.yearTitleFormat);\n              scope.showLabels = false;\n              scope.rows = split(months, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualMonth = picker.$date.getMonth();\n              var newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setMonth(actualMonth - 1);\n              else if(evt.keyCode === 38) newDate.setMonth(actualMonth - 4);\n              else if(evt.keyCode === 39) newDate.setMonth(actualMonth + 1);\n              else if(evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }, {\n            name: 'year',\n            format: options.yearFormat,\n            split: 4,\n            steps: { year: 12 },\n            update: function(date, force) {\n              if(!this.built || force || parseInt(date.getFullYear()/20, 10) !== parseInt(viewDate.year/20, 10)) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$build();\n              } else if(date.getFullYear() !== viewDate.year) {\n                angular.extend(viewDate, {year: picker.$date.getFullYear(), month: picker.$date.getMonth(), date: picker.$date.getDate()});\n                picker.$updateSelected();\n              }\n            },\n            build: function() {\n              var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n              var years = [], year;\n              for (var i = 0; i < 12; i++) {\n                year = new Date(firstYear + i, 0, 1);\n                years.push({date: year, label: formatDate(year, this.format), selected: picker.$isSelected(year), disabled: this.isDisabled(year)});\n              }\n              scope.title = years[0].label + '-' + years[years.length - 1].label;\n              scope.showLabels = false;\n              scope.rows = split(years, this.split);\n              this.built = true;\n            },\n            isSelected: function(date) {\n              return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n            },\n            isDisabled: function(date) {\n              var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n              return lastDate < options.minDate || date.getTime() > options.maxDate;\n            },\n            onKeyDown: function(evt) {\n              if (!picker.$date) {\n                return;\n              }\n              var actualYear = picker.$date.getFullYear(),\n                  newDate = new Date(picker.$date);\n\n              if(evt.keyCode === 37) newDate.setYear(actualYear - 1);\n              else if(evt.keyCode === 38) newDate.setYear(actualYear - 4);\n              else if(evt.keyCode === 39) newDate.setYear(actualYear + 1);\n              else if(evt.keyCode === 40) newDate.setYear(actualYear + 4);\n\n              if (!this.isDisabled(newDate)) picker.select(newDate, true);\n            }\n          }];\n\n        return {\n          views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n          viewDate: viewDate\n        };\n\n      };\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      template: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory(element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var scope = $dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function(evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if(!items.length) return;\n          var index;\n          angular.forEach(items, function(el, i) {\n            if(matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if(evt.keyCode === 38 && index > 0) index--;\n          else if(evt.keyCode === 40 && index < items.length - 1) index++;\n          else if(angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            options.keyboard && $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          parentEl.hasClass('dropdown') && parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function() {\n          if(!$dropdown.$isShown) return;\n          options.keyboard && $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          parentEl.hasClass('dropdown') && parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function() {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick(evt) {\n          if(evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as an object\n        attr.bsDropdown && scope.$watch(attr.bsDropdown, function(newValue, oldValue) {\n          scope.content = newValue;\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!dropdown || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n          newValue === true ? dropdown.show() : dropdown.hide();\n        });\n\n        // Initialize dropdown\n        var dropdown = $dropdown(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (dropdown) dropdown.destroy();\n          options = null;\n          dropdown = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function() {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function(format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function(lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat(format) {\n      return /(h+)([:\\.])?(m+)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function(timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function(timeFormat) {\n      return !!splitTimeFormat(timeFormat)[3];\n    };\n\n    this.formatDate = function(date, format, lang, timezone){\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate() {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\n  ParseDate.prototype.getHours = function() { return this.hours; };\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\n  ParseDate.prototype.fromDate = function(value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function() {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop() {\n  }\n\n  function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive(array, value) {\n    var len = array.length, str=value.toString().toLowerCase();\n    for (var i=0; i<len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function($locale, dateFilter) {\n\n    var DateParserFactory = function(config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : proto.setFullYear\n      };\n\n      var regex, setMap;\n\n      $dateParser.init = function() {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function(date) {\n        if(angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function(value, baseDate, format, timezone) {\n        // check for date format special names\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if(!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for(var i = 0; i < matches.length - 1; i++) {\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function(key, value) {\n        var date;\n\n        if(value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if(isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function(key, value) {\n        var time;\n\n        if(value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if(isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function(date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function setMapForFormat(format) {\n        var keys = Object.keys(setFnMap), i;\n        var map = [], sortedMap = [];\n        // Map to setFn\n        var clonedFormat = format;\n        for(i = 0; i < keys.length; i++) {\n          if(format.split(keys[i]).length > 1) {\n            var index = clonedFormat.search(keys[i]);\n            format = format.split(keys[i]).join('');\n            if(setFnMap[keys[i]]) {\n              map[index] = setFnMap[keys[i]];\n            }\n          }\n        }\n        // Sort result map\n        angular.forEach(map, function(v) {\n          // conditional required since angular.forEach broke around v1.2.21\n          // related pr: https://github.com/angular/angular.js/pull/8525\n          if(v) sortedMap.push(v);\n        });\n        return sortedMap;\n      }\n\n      function escapeReservedSymbols(text) {\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function regExpForFormat(format) {\n        var keys = Object.keys(regExpMap), i;\n\n        var re = format;\n        // Abstract replaces to avoid collisions\n        for(i = 0; i < keys.length; i++) {\n          re = re.split(keys[i]).join('${' + i + '}');\n        }\n        // Replace abstracted values\n        for(i = 0; i < keys.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\n        }\n        format = escapeReservedSymbols(format);\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function($timeout) {\n  return function(func, wait, immediate) {\n    var timeout = null;\n    return function() {\n      var context = this,\n        args = arguments,\n        callNow = immediate && !timeout;\n      if(timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later() {\n        timeout = null;\n        if(!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if(callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function($timeout) {\n  return function(func, wait, options) {\n    var timeout = null;\n    options || (options = {});\n    return function() {\n      var context = this,\n        args = arguments;\n      if(!timeout) {\n        if(options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later() {\n          timeout = null;\n          if(options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n  \n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = fn.css(element, 'position'),\n          curElem = angular.element(element),\n          props = {};\n      \n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n      \n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') && \n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n      \n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      \n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n      \n      if (options.top !== null ) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if ( options.left !== null ) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function() {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function($parse, $q) {\n\n      function ParseOptionsFactory(attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match, displayFn, valueName, keyName, groupByFn, valueFn, valuesFn;\n\n        $parseOptions.init = function() {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]),\n          valueName = match[4] || match[6],\n          keyName = match[5],\n          groupByFn = $parse(match[3] || ''),\n          valueFn = $parse(match[2] ? match[1] : valueName),\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function(scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function(values) {\n            $parseOptions.$values = values ? parseValues(values, scope) : {};\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function(modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues(values, scope) {\n          return values.map(function(match, index) {\n            var locals = {}, label, value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\n(angular.version.minor < 3 && angular.version.dot < 14) && angular.module('ng')\n\n.factory('$$rAF', function($window, $timeout) {\n\n  var requestAnimationFrame = $window.requestAnimationFrame ||\n                              $window.webkitRequestAnimationFrame ||\n                              $window.mozRequestAnimationFrame;\n\n  var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                             $window.webkitCancelAnimationFrame ||\n                             $window.mozCancelAnimationFrame ||\n                             $window.webkitCancelRequestAnimationFrame;\n\n  var rafSupported = !!requestAnimationFrame;\n  var raf = rafSupported ?\n    function(fn) {\n      var id = requestAnimationFrame(fn);\n      return function() {\n        cancelAnimationFrame(id);\n      };\n    } :\n    function(fn) {\n      var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n      return function() {\n        $timeout.cancel(timer);\n      };\n    };\n\n  raf.supported = rafSupported;\n\n  return raf;\n\n});\n\n// .factory('$$animateReflow', function($$rAF, $document) {\n\n//   var bodyEl = $document[0].body;\n\n//   return function(fn) {\n//     //the returned function acts as the cancellation function\n//     return $$rAF(function() {\n//       //the line below will force the browser to perform a repaint\n//       //so that all the animated elements within the animation frame\n//       //will be properly updated and drawn on screen. This is\n//       //required to perform multi-class CSS based animations with\n//       //Firefox. DO NOT REMOVE THIS LINE.\n//       var a = bodyEl.offsetWidth + 1;\n//       fn();\n//     });\n//   };\n\n// });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$modal', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      template: 'modal/modal.tpl.html',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $timeout, $sce, dimensions) {\n\n      var forEach = angular.forEach;\n      var trim = String.prototype.trim;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n\n      function ModalFactory(config) {\n\n        var $modal = {};\n\n        // Common vars\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        $modal.$promise = fetchTemplate(options.template);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(!options.element && !options.container) {\n          options.container = 'body';\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n\n        // Support scope as string options\n        forEach(['title', 'content'], function(key) {\n          if(options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $modal.$isShown = scope.$isShown = false;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $modal.$promise = $modal.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]).removeAttr('ng-bind').html(contentTemplate);\n              // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n              if(!config.template) contentEl.next().remove();\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize modal\n        var modalLinker, modalElement;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        backdropElement.css({position:'fixed', top:'0px', left:'0px', bottom:'0px', right:'0px', 'z-index': 1038});\n        $modal.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          modalLinker = $compile(template);\n          $modal.init();\n        });\n\n        $modal.init = function() {\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n\n        };\n\n        $modal.destroy = function() {\n\n          // Remove element\n          if(modalElement) {\n            modalElement.remove();\n            modalElement = null;\n          }\n          if(backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $modal.show = function() {\n          if($modal.$isShown) return;\n\n          var parent, after;\n          if(angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          } else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n\n          // Fetch a cloned element linked from template\n          modalElement = $modal.$element = modalLinker(scope, function(clonedElement, scope) {});\n\n          if(scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n\n          // Set the initial positioning.\n          modalElement.css({display: 'block'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) {\n            if(options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n\n          if(options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          // Focus once the enter-animation has started\n          // Weird PhantomJS bug hack\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n\n          bodyElement.addClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n\n          // Bind events\n          if(options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n        }\n\n        $modal.hide = function() {\n          if(!$modal.$isShown) return;\n\n          if(scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          var promise = $animate.leave(modalElement, leaveAnimateCallback);\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          if(options.backdrop) {\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n          if(options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          bodyElement.removeClass(options.prefixClass + '-open');\n          if(options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n\n        $modal.toggle = function() {\n\n          $modal.$isShown ? $modal.hide() : $modal.show();\n\n        };\n\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n\n        // Protected methods\n\n        $modal.$onKeyUp = function(evt) {\n\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n\n        };\n\n        // Private methods\n\n        function hideOnBackdropClick(evt) {\n          if(evt.target !== evt.currentTarget) return;\n          options.backdrop === 'static' ? $modal.focus() : $modal.hide();\n        }\n\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n\n        return $modal;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return ModalFactory;\n\n    };\n\n  })\n\n  .directive('bsModal', function($window, $sce, $modal) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'animation', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['keyboard', 'html'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        if(angular.isDefined(attr.backdrop)) {\n          options.backdrop = falseValueRegExp.test(attr.backdrop) ? false : attr.backdrop;\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n          });\n        });\n\n        // Support scope as an object\n        attr.bsModal && scope.$watch(attr.bsModal, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n        }, true);\n\n        // Initialize modal\n        var modal = $modal(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', modal.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.navbar', [])\n\n  .provider('$navbar', function() {\n\n    var defaults = this.defaults = {\n      activeClass: 'active',\n      routeAttr: 'data-match-route',\n      strict: false\n    };\n\n    this.$get = function() {\n      return {defaults: defaults};\n    };\n\n  })\n\n  .directive('bsNavbar', function($window, $location, $navbar) {\n\n    var defaults = $navbar.defaults;\n\n    return {\n      restrict: 'A',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = angular.copy(defaults);\n        angular.forEach(Object.keys(defaults), function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Watch for the $location\n        scope.$watch(function() {\n\n          return $location.path();\n\n        }, function(newValue, oldValue) {\n\n          var liElements = element[0].querySelectorAll('li[' + options.routeAttr + ']');\n\n          angular.forEach(liElements, function(li) {\n\n            var liElement = angular.element(li);\n            var pattern = liElement.attr(options.routeAttr).replace('/', '\\\\/');\n            if(options.strict) {\n              pattern = '^' + pattern + '$';\n            }\n            var regexp = new RegExp(pattern, 'i');\n\n            if(regexp.test(newValue)) {\n              liElement.addClass(options.activeClass);\n            } else {\n              liElement.removeClass(options.activeClass);\n            }\n\n          });\n\n        });\n\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      container: false,\n      target: false,\n      placement: 'right',\n      template: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass', 'autoClose', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n        \n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          popover.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.scrollspy', ['mgcrea.ngStrap.helpers.debounce', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$scrollspy', function() {\n\n    // Pool of registered spies\n    var spies = this.$$spies = {};\n\n    var defaults = this.defaults = {\n      debounce: 150,\n      throttle: 100,\n      offset: 100\n    };\n\n    this.$get = function($window, $document, $rootScope, dimensions, debounce, throttle) {\n\n      var windowEl = angular.element($window);\n      var docEl = angular.element($document.prop('documentElement'));\n      var bodyEl = angular.element($window.document.body);\n\n      // Helper functions\n\n      function nodeName(element, name) {\n        return element[0].nodeName && element[0].nodeName.toLowerCase() === name.toLowerCase();\n      }\n\n      function ScrollSpyFactory(config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        if(!options.element) options.element = bodyEl;\n        var isWindowSpy = nodeName(options.element, 'body');\n        var scrollEl = isWindowSpy ? windowEl : options.element;\n        var scrollId = isWindowSpy ? 'window' : options.id;\n\n        // Use existing spy\n        if(spies[scrollId]) {\n          spies[scrollId].$$count++;\n          return spies[scrollId];\n        }\n\n        var $scrollspy = {};\n\n        // Private vars\n        var unbindViewContentLoaded, unbindIncludeContentLoaded;\n        var trackedElements = $scrollspy.$trackedElements = [];\n        var sortedElements = [];\n        var activeTarget;\n        var debouncedCheckPosition;\n        var throttledCheckPosition;\n        var debouncedCheckOffsets;\n        var viewportHeight;\n        var scrollTop;\n\n        $scrollspy.init = function() {\n\n          // Setup internal ref counter\n          this.$$count = 1;\n\n          // Bind events\n          debouncedCheckPosition = debounce(this.checkPosition, options.debounce);\n          throttledCheckPosition = throttle(this.checkPosition, options.throttle);\n          scrollEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', debouncedCheckPosition);\n          scrollEl.on('scroll', throttledCheckPosition);\n\n          debouncedCheckOffsets = debounce(this.checkOffsets, options.debounce);\n          unbindViewContentLoaded = $rootScope.$on('$viewContentLoaded', debouncedCheckOffsets);\n          unbindIncludeContentLoaded = $rootScope.$on('$includeContentLoaded', debouncedCheckOffsets);\n          debouncedCheckOffsets();\n\n          // Register spy for reuse\n          if(scrollId) {\n            spies[scrollId] = $scrollspy;\n          }\n\n        };\n\n        $scrollspy.destroy = function() {\n\n          // Check internal ref counter\n          this.$$count--;\n          if(this.$$count > 0) {\n            return;\n          }\n\n          // Unbind events\n          scrollEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', debouncedCheckPosition);\n          scrollEl.off('scroll', throttledCheckPosition);\n          unbindViewContentLoaded();\n          unbindIncludeContentLoaded();\n          if (scrollId) {\n            delete spies[scrollId];\n          }\n        };\n\n        $scrollspy.checkPosition = function() {\n\n          // Not ready yet\n          if(!sortedElements.length) return;\n\n          // Calculate the scroll position\n          scrollTop = (isWindowSpy ? $window.pageYOffset : scrollEl.prop('scrollTop')) || 0;\n\n          // Calculate the viewport height for use by the components\n          viewportHeight = Math.max($window.innerHeight, docEl.prop('clientHeight'));\n\n          // Activate first element if scroll is smaller\n          if(scrollTop < sortedElements[0].offsetTop && activeTarget !== sortedElements[0].target) {\n            return $scrollspy.$activateElement(sortedElements[0]);\n          }\n\n          // Activate proper element\n          for (var i = sortedElements.length; i--;) {\n            if(angular.isUndefined(sortedElements[i].offsetTop) || sortedElements[i].offsetTop === null) continue;\n            if(activeTarget === sortedElements[i].target) continue;\n            if(scrollTop < sortedElements[i].offsetTop) continue;\n            if(sortedElements[i + 1] && scrollTop > sortedElements[i + 1].offsetTop) continue;\n            return $scrollspy.$activateElement(sortedElements[i]);\n          }\n\n        };\n\n        $scrollspy.checkPositionWithEventLoop = function() {\n          // IE 9 throws an error if we use 'this' instead of '$scrollspy'\n          // in this setTimeout call\n          setTimeout($scrollspy.checkPosition, 1);\n        };\n\n        // Protected methods\n\n        $scrollspy.$activateElement = function(element) {\n          if(activeTarget) {\n            var activeElement = $scrollspy.$getTrackedElement(activeTarget);\n            if(activeElement) {\n              activeElement.source.removeClass('active');\n              if(nodeName(activeElement.source, 'li') && nodeName(activeElement.source.parent().parent(), 'li')) {\n                activeElement.source.parent().parent().removeClass('active');\n              }\n            }\n          }\n          activeTarget = element.target;\n          element.source.addClass('active');\n          if(nodeName(element.source, 'li') && nodeName(element.source.parent().parent(), 'li')) {\n            element.source.parent().parent().addClass('active');\n          }\n        };\n\n        $scrollspy.$getTrackedElement = function(target) {\n          return trackedElements.filter(function(obj) {\n            return obj.target === target;\n          })[0];\n        };\n\n        // Track offsets behavior\n\n        $scrollspy.checkOffsets = function() {\n\n          angular.forEach(trackedElements, function(trackedElement) {\n            var targetElement = document.querySelector(trackedElement.target);\n            trackedElement.offsetTop = targetElement ? dimensions.offset(targetElement).top : null;\n            if(options.offset && trackedElement.offsetTop !== null) trackedElement.offsetTop -= options.offset * 1;\n          });\n\n          sortedElements = trackedElements\n          .filter(function(el) {\n            return el.offsetTop !== null;\n          })\n          .sort(function(a, b) {\n            return a.offsetTop - b.offsetTop;\n          });\n\n          debouncedCheckPosition();\n\n        };\n\n        $scrollspy.trackElement = function(target, source) {\n          trackedElements.push({target: target, source: source});\n        };\n\n        $scrollspy.untrackElement = function(target, source) {\n          var toDelete;\n          for (var i = trackedElements.length; i--;) {\n            if(trackedElements[i].target === target && trackedElements[i].source === source) {\n              toDelete = i;\n              break;\n            }\n          }\n          trackedElements = trackedElements.splice(toDelete, 1);\n        };\n\n        $scrollspy.activate = function(i) {\n          trackedElements[i].addClass('active');\n        };\n\n        // Initialize plugin\n\n        $scrollspy.init();\n        return $scrollspy;\n\n      }\n\n      return ScrollSpyFactory;\n\n    };\n\n  })\n\n  .directive('bsScrollspy', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'EAC',\n      link: function postLink(scope, element, attr) {\n\n        var options = {scope: scope};\n        angular.forEach(['offset', 'target'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        var scrollspy = $scrollspy(options);\n        scrollspy.trackElement(options.target, element);\n\n        scope.$on('$destroy', function() {\n          if (scrollspy) {\n            scrollspy.untrackElement(options.target, element);\n            scrollspy.destroy();\n          }\n          options = null;\n          scrollspy = null;\n        });\n\n      }\n    };\n\n  })\n\n\n  .directive('bsScrollspyList', function($rootScope, debounce, dimensions, $scrollspy) {\n\n    return {\n      restrict: 'A',\n      compile: function postLink(element, attr) {\n        var children = element[0].querySelectorAll('li > a[href]');\n        angular.forEach(children, function(child) {\n          var childEl = angular.element(child);\n          childEl.parent().attr('bs-scrollspy', '').attr('data-target', childEl.attr('href'));\n        });\n      }\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      template: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok'\n    };\n\n    this.$get = function($window, $document, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory(element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        // parse sort option value to support attribute as string\n        // when binded to interpolated value\n        options.sort = options.sort.toString().match(/true|1/i);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        scope.$activeIndex = -1;\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function(index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function(matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function(index) {\n          if(options.multiple) {\n            $select.$isActive(index) ? scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1) : scope.$activeIndex.push(index);\n            if(options.sort) scope.$activeIndex.sort();\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function(index) {\n          var value = scope.$matches[index].value;\n          scope.$apply(function() {\n            $select.activate(index);\n            if(options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function(index) {\n                return scope.$matches[index].value;\n              }));\n            } else {\n              controller.$setViewValue(value);\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function() {\n          if(controller.$modelValue && scope.$matches.length) {\n            if(options.multiple && angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function(value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            }\n          } else if(scope.$activeIndex >= scope.$matches.length) {\n            scope.$activeIndex = options.multiple ? [] : 0;\n          }\n        };\n\n        $select.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function(index) {\n          if(options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          } else {\n            return scope.$activeIndex === index;\n          }\n        };\n\n        $select.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $select.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $select.$onKeyDown = function(evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if(!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if(evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function() {\n          _show();\n          if(options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function() {\n          if(!options.multiple && !controller.$modelValue) {\n            scope.$activeIndex = -1;\n          } \n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'placeholder', 'multiple', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Add support for select markup\n        if(element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected, index;\n          if(options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function(value) {\n              index = select.$getIndex(value);\n              return angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if(selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = angular.isDefined(index) ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected ? selected : options.placeholder) + (options.caretHtml ? options.caretHtml : defaults.caretHtml));\n        };\n\n        if(options.multiple){\n          controller.$isEmpty = function(value){\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', [])\n\n  .provider('$tab', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      template: 'tab/tab.tpl.html',\n      navClass: 'nav-tabs',\n      activeClass: 'active'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      var self = this;\n\n      // Attributes options\n      self.$options = angular.copy(defaults);\n      angular.forEach(['animation', 'navClass', 'activeClass'], function(key) {\n        if(angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n      });\n\n      // Publish options on scope\n      $scope.$navClass = self.$options.navClass;\n      $scope.$activeClass = self.$options.activeClass;\n\n      self.$panes = $scope.$panes = [];\n\n      // DEPRECATED: $viewChangeListeners, please use $activePaneChangeListeners\n      // Because we deprecated ngModel usage, we rename viewChangeListeners to \n      // activePaneChangeListeners to make more sense.\n      self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n\n      self.$push = function(pane) {\n        self.$panes.push(pane);\n      };\n\n      self.$remove = function(pane) {\n        var index = self.$panes.indexOf(pane);\n        var activeIndex = self.$panes.$active;\n\n        // remove pane from $panes array\n        self.$panes.splice(index, 1);\n\n        if (index < activeIndex) {\n          // we removed a pane before the active pane, so we need to \n          // decrement the active pane index\n          activeIndex--;\n        }\n        else if (index === activeIndex && activeIndex === self.$panes.length) {\n          // we remove the active pane and it was the one at the end,\n          // so select the previous one\n          activeIndex--;\n        }\n        self.$setActive(activeIndex);\n      };\n\n      self.$panes.$active = 0;\n      self.$setActive = $scope.$setActive = function(value) {\n        self.$panes.$active = value;\n        self.$activePaneChangeListeners.forEach(function(fn) {\n          fn();\n        });\n      };\n\n    };\n\n    this.$get = function() {\n      var $tab = {};\n      $tab.defaults = defaults;\n      $tab.controller = controller;\n      return $tab;\n    };\n\n  })\n\n  .directive('bsTabs', function($window, $animate, $tab, $parse) {\n\n    var defaults = $tab.defaults;\n\n    return {\n      require: ['?ngModel', 'bsTabs'],\n      transclude: true,\n      scope: true,\n      controller: ['$scope', '$element', '$attrs', $tab.controller],\n      templateUrl: function(element, attr) {\n        return attr.template || defaults.template;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // DEPRECATED: ngModel, please use bsActivePane\n        // 'ngModel' is deprecated bacause if interferes with form validation\n        // and status, so avoid using it here.\n        if(ngModelCtrl) {\n          console.warn('Usage of ngModel is deprecated, please use bsActivePane instead!');\n\n          // Update the modelValue following\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n          });\n\n          // modelValue -> $formatters -> viewValue\n          ngModelCtrl.$formatters.push(function(modelValue) {\n            // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n            bsTabsCtrl.$setActive(modelValue * 1);\n            return modelValue;\n          });\n\n        }\n\n        if (attrs.bsActivePane) {\n          // adapted from angularjs ngModelController bindings\n          // https://github.com/angular/angular.js/blob/v1.3.1/src%2Fng%2Fdirective%2Finput.js#L1730\n          var parsedBsActivePane = $parse(attrs.bsActivePane);\n\n          // Update bsActivePane value with change\n          bsTabsCtrl.$activePaneChangeListeners.push(function() {\n            parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n          });\n\n          // watch bsActivePane for value changes\n          scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n            bsTabsCtrl.$setActive(newValue * 1);\n          }, true);\n        }\n      }\n    };\n\n  })\n\n  .directive('bsPane', function($window, $animate, $sce) {\n\n    return {\n      require: ['^?ngModel', '^bsTabs'],\n      scope: true,\n      link: function postLink(scope, element, attrs, controllers) {\n\n        var ngModelCtrl = controllers[0];\n        var bsTabsCtrl = controllers[1];\n\n        // Add base class\n        element.addClass('tab-pane');\n\n        // Observe title attribute for change\n        attrs.$observe('title', function(newValue, oldValue) {\n          scope.title = $sce.trustAsHtml(newValue);\n        });\n\n        // Add animation class\n        if(bsTabsCtrl.$options.animation) {\n          element.addClass(bsTabsCtrl.$options.animation);\n        }\n\n        attrs.$observe('disabled', function(newValue, oldValue) {\n          scope.disabled = scope.$eval(newValue);\n        });\n\n        // Push pane to parent bsTabs controller\n        bsTabsCtrl.$push(scope);\n\n        // remove pane from tab controller when pane is destroyed\n        scope.$on('$destroy', function() {\n          bsTabsCtrl.$remove(scope);\n        });\n\n        function render() {\n          var index = bsTabsCtrl.$panes.indexOf(scope);\n          var active = bsTabsCtrl.$panes.$active;\n          $animate[index === active ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n        }\n\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          render();\n        });\n        render();\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [\n  'mgcrea.ngStrap.helpers.dateParser',\n  'mgcrea.ngStrap.helpers.dateFormatter',\n  'mgcrea.ngStrap.tooltip'])\n\n  .provider('$timepicker', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'timepicker',\n      placement: 'bottom-left',\n      template: 'timepicker/timepicker.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      // lang: $locale.id,\n      useNative: true,\n      timeType: 'date',\n      timeFormat: 'shortTime',\n      timezone: null,\n      modelTimeFormat: null,\n      autoclose: false,\n      minTime: -Infinity,\n      maxTime: +Infinity,\n      length: 5,\n      hourStep: 1,\n      minuteStep: 5,\n      roundDisplay: false,\n      iconUp: 'glyphicon glyphicon-chevron-up',\n      iconDown: 'glyphicon glyphicon-chevron-down',\n      arrowBehavior: 'pager'\n    };\n\n    this.$get = function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      if(!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n\n      function timepickerFactory(element, controller, config) {\n\n        var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n        var parentScope = config.scope;\n        var options = $timepicker.$options;\n        var scope = $timepicker.$scope;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        function floorMinutes(time)\n        {\n          // coeff used to floor current time to nearest minuteStep interval\n          var coeff = 1000 * 60 * options.minuteStep;\n          return new Date(Math.floor(time.getTime() / coeff) * coeff);\n        }\n\n        // View vars\n\n        var selectedIndex = 0;\n        var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n        var startDate = controller.$dateValue || defaultDate;\n        var viewDate = {hour: startDate.getHours(), meridian: startDate.getHours() < 12, minute: startDate.getMinutes(), second: startDate.getSeconds(), millisecond: startDate.getMilliseconds()};\n\n        var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n\n        var hoursFormat = $dateFormatter.hoursFormat(format),\n          timeSeparator = $dateFormatter.timeSeparator(format),\n          minutesFormat = $dateFormatter.minutesFormat(format),\n          showAM = $dateFormatter.showAM(format);\n\n        scope.$iconUp = options.iconUp;\n        scope.$iconDown = options.iconDown;\n\n        // Scope methods\n\n        scope.$select = function(date, index) {\n          $timepicker.select(date, index);\n        };\n        scope.$moveIndex = function(value, index) {\n          $timepicker.$moveIndex(value, index);\n        };\n        scope.$switchMeridian = function(date) {\n          $timepicker.switchMeridian(date);\n        };\n\n        // Public methods\n\n        $timepicker.update = function(date) {\n          // console.warn('$timepicker.update() newValue=%o', date);\n          if(angular.isDate(date) && !isNaN(date.getTime())) {\n            $timepicker.$date = date;\n            angular.extend(viewDate, {hour: date.getHours(), minute: date.getMinutes(), second: date.getSeconds(), millisecond: date.getMilliseconds()});\n            $timepicker.$build();\n          } else if(!$timepicker.$isBuilt) {\n            $timepicker.$build();\n          }\n        };\n\n        $timepicker.select = function(date, index, keep) {\n          // console.warn('$timepicker.select', date, scope.$mode);\n          if(!controller.$dateValue || isNaN(controller.$dateValue.getTime())) controller.$dateValue = new Date(1970, 0, 1);\n          if(!angular.isDate(date)) date = new Date(date);\n          if(index === 0) controller.$dateValue.setHours(date.getHours());\n          else if(index === 1) controller.$dateValue.setMinutes(date.getMinutes());\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n          if(options.autoclose && !keep) {\n            $timeout(function() { $timepicker.hide(true); });\n          }\n        };\n\n        $timepicker.switchMeridian = function(date) {\n          if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n            return;\n          }\n          var hours = (date || controller.$dateValue).getHours();\n          controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n          controller.$setViewValue(angular.copy(controller.$dateValue));\n          controller.$render();\n        };\n\n        // Protected methods\n\n        $timepicker.$build = function() {\n          // console.warn('$timepicker.$build() viewDate=%o', viewDate);\n          var i, midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n          var hours = [], hour;\n          for(i = 0; i < options.length; i++) {\n            hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n            hours.push({date: hour, label: formatDate(hour, hoursFormat), selected: $timepicker.$date && $timepicker.$isSelected(hour, 0), disabled: $timepicker.$isDisabled(hour, 0)});\n          }\n          var minutes = [], minute;\n          for(i = 0; i < options.length; i++) {\n            minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n            minutes.push({date: minute, label: formatDate(minute, minutesFormat), selected: $timepicker.$date && $timepicker.$isSelected(minute, 1), disabled: $timepicker.$isDisabled(minute, 1)});\n          }\n\n          var rows = [];\n          for(i = 0; i < options.length; i++) {\n            rows.push([hours[i], minutes[i]]);\n          }\n          scope.rows = rows;\n          scope.showAM = showAM;\n          scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n          scope.timeSeparator = timeSeparator;\n          $timepicker.$isBuilt = true;\n        };\n\n        $timepicker.$isSelected = function(date, index) {\n          if(!$timepicker.$date) return false;\n          else if(index === 0) {\n            return date.getHours() === $timepicker.$date.getHours();\n          } else if(index === 1) {\n            return date.getMinutes() === $timepicker.$date.getMinutes();\n          }\n        };\n\n        $timepicker.$isDisabled = function(date, index) {\n          var selectedTime;\n          if(index === 0) {\n            selectedTime = date.getTime() + viewDate.minute * 6e4;\n          } else if(index === 1) {\n            selectedTime = date.getTime() + viewDate.hour * 36e5;\n          }\n          return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n        };\n\n        scope.$arrowAction = function (value, index) {\n          if (options.arrowBehavior === 'picker') {\n            $timepicker.$setTimeByStep(value,index);\n          } else {\n            $timepicker.$moveIndex(value,index);\n          }\n        };\n\n        $timepicker.$setTimeByStep = function(value, index) {\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          if (index === 0) {\n            newDate.setHours(hours - (parseInt(options.hourStep, 10) * value));\n          }\n          else {\n            newDate.setMinutes(minutes - (parseInt(options.minuteStep, 10) * value));\n          }\n          $timepicker.select(newDate, index, true);\n        };\n\n        $timepicker.$moveIndex = function(value, index) {\n          var targetDate;\n          if(index === 0) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour + (value * options.length), viewDate.minute);\n            angular.extend(viewDate, {hour: targetDate.getHours()});\n          } else if(index === 1) {\n            targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + (value * options.length * options.minuteStep));\n            angular.extend(viewDate, {minute: targetDate.getMinutes()});\n          }\n          $timepicker.$build();\n        };\n\n        $timepicker.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          if(evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if(isTouch) {\n            var targetEl = angular.element(evt.target);\n            if(targetEl[0].nodeName.toLowerCase() !== 'button') {\n              targetEl = targetEl.parent();\n            }\n            targetEl.triggerHandler('click');\n          }\n        };\n\n        $timepicker.$onKeyDown = function(evt) {\n          if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Close on enter\n          if(evt.keyCode === 13) return $timepicker.hide(true);\n\n          // Navigate with keyboard\n          var newDate = new Date($timepicker.$date);\n          var hours = newDate.getHours(), hoursLength = formatDate(newDate, hoursFormat).length;\n          var minutes = newDate.getMinutes(), minutesLength = formatDate(newDate, minutesFormat).length;\n          var lateralMove = /(37|39)/.test(evt.keyCode);\n          var count = 2 + showAM * 1;\n\n          // Navigate indexes (left, right)\n          if (lateralMove) {\n            if(evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1;\n            else if(evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n          }\n\n          // Update values (up, down)\n          var selectRange = [0, hoursLength];\n          if(selectedIndex === 0) {\n            if(evt.keyCode === 38) newDate.setHours(hours - parseInt(options.hourStep, 10));\n            else if(evt.keyCode === 40) newDate.setHours(hours + parseInt(options.hourStep, 10));\n            // re-calculate hours length because we have changed hours value\n            hoursLength = formatDate(newDate, hoursFormat).length;\n            selectRange = [0, hoursLength];\n          } else if(selectedIndex === 1) {\n            if(evt.keyCode === 38) newDate.setMinutes(minutes - parseInt(options.minuteStep, 10));\n            else if(evt.keyCode === 40) newDate.setMinutes(minutes + parseInt(options.minuteStep, 10));\n            // re-calculate minutes length because we have changes minutes value\n            minutesLength = formatDate(newDate, minutesFormat).length;\n            selectRange = [hoursLength + 1, hoursLength + 1 + minutesLength];\n          } else if(selectedIndex === 2) {\n            if(!lateralMove) $timepicker.switchMeridian();\n            selectRange = [hoursLength + 1 + minutesLength + 1, hoursLength + 1 + minutesLength + 3];\n          }\n          $timepicker.select(newDate, selectedIndex, true);\n          createSelection(selectRange[0], selectRange[1]);\n          parentScope.$digest();\n        };\n\n        // Private\n\n        function createSelection(start, end) {\n          if(element[0].createTextRange) {\n            var selRange = element[0].createTextRange();\n            selRange.collapse(true);\n            selRange.moveStart('character', start);\n            selRange.moveEnd('character', end);\n            selRange.select();\n          } else if(element[0].setSelectionRange) {\n            element[0].setSelectionRange(start, end);\n          } else if(angular.isUndefined(element[0].selectionStart)) {\n            element[0].selectionStart = start;\n            element[0].selectionEnd = end;\n          }\n        }\n\n        function focusElement() {\n          element[0].focus();\n        }\n\n        // Overrides\n\n        var _init = $timepicker.init;\n        $timepicker.init = function() {\n          if(isNative && options.useNative) {\n            element.prop('type', 'time');\n            element.css('-webkit-appearance', 'textfield');\n            return;\n          } else if(isTouch) {\n            element.prop('type', 'text');\n            element.attr('readonly', 'true');\n            element.on('click', focusElement);\n          }\n          _init();\n        };\n\n        var _destroy = $timepicker.destroy;\n        $timepicker.destroy = function() {\n          if(isNative && options.useNative) {\n            element.off('click', focusElement);\n          }\n          _destroy();\n        };\n\n        var _show = $timepicker.show;\n        $timepicker.show = function() {\n          _show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $timepicker.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $timepicker.hide;\n        $timepicker.hide = function(blur) {\n          if(!$timepicker.$isShown) return;\n          $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $timepicker.$onKeyDown);\n          }\n          _hide(blur);\n        };\n\n        return $timepicker;\n\n      }\n\n      timepickerFactory.defaults = defaults;\n      return timepickerFactory;\n\n    };\n\n  })\n\n\n  .directive('bsTimepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n\n    var defaults = $timepicker.defaults;\n    var isNative = /(ip(a|o)d|iphone|android)/ig.test($window.navigator.userAgent);\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, controller: controller};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match for boolean values\n        var falseValueRegExp = /^(false|0|)$/;\n        angular.forEach(['roundDisplay'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = !falseValueRegExp.test(attr[key]);\n        });\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!timepicker || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          newValue === true ? timepicker.show() : timepicker.hide();\n        });\n\n        // Initialize timepicker\n        if(isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n        var timepicker = $timepicker(element, controller, options);\n        options = timepicker.$options;\n\n        var lang = options.lang;\n        var formatDate = function(date, format, timezone) {\n          return $dateFormatter.formatDate(date, format, lang, timezone);\n        };\n\n        // Initialize parser\n        var dateParser = $dateParser({format: options.timeFormat, lang: lang});\n\n        // Observe attributes for changes\n        angular.forEach(['minTime', 'maxTime'], function(key) {\n          // console.warn('attr.$observe(%s)', key, attr[key]);\n          angular.isDefined(attr[key]) && attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            !isNaN(timepicker.$options[key]) && timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        });\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue, controller.$dateValue);\n          timepicker.update(controller.$dateValue);\n        }, true);\n\n        function validateAgainstMinMaxTime(parsedTime) {\n          if (!angular.isDate(parsedTime)) return;\n          var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n          var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n          var isValid = isMinValid && isMaxValid;\n          controller.$setValidity('date', isValid);\n          controller.$setValidity('min', isMinValid);\n          controller.$setValidity('max', isMaxValid);\n          // Only update the model when we have a valid date\n          if(!isValid) {\n              return;\n          }\n          controller.$dateValue = parsedTime;\n        }\n\n        // viewValue -> $parsers -> modelValue\n        controller.$parsers.unshift(function(viewValue) {\n          // console.warn('$parser(\"%s\"): viewValue=%o', element.attr('ng-model'), viewValue);\n          var date;\n          // Null values should correctly reset the model value & validity\n          if(!viewValue) {\n            // BREAKING CHANGE:\n            // return null (not undefined) when input value is empty, so angularjs 1.3\n            // ngModelController can go ahead and run validators, like ngRequired\n            controller.$setValidity('date', true);\n            return null;\n          }\n          var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n          if(!parsedTime || isNaN(parsedTime.getTime())) {\n            controller.$setValidity('date', false);\n            // return undefined, causes ngModelController to\n            // invalidate model value\n            return;\n          } else {\n            validateAgainstMinMaxTime(parsedTime);\n          }\n\n          if(options.timeType === 'string') {\n            date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n            return formatDate(date, options.modelTimeFormat || options.timeFormat);\n          }\n          date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n          if(options.timeType === 'number') {\n            return date.getTime();\n          } else if(options.timeType === 'unix') {\n            return date.getTime() / 1000;\n          } else if(options.timeType === 'iso') {\n            return date.toISOString();\n          } else {\n            return new Date(date);\n          }\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var date;\n          if(angular.isUndefined(modelValue) || modelValue === null) {\n            date = NaN;\n          } else if(angular.isDate(modelValue)) {\n            date = modelValue;\n          } else if(options.timeType === 'string') {\n            date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n          } else if(options.timeType === 'unix') {\n            date = new Date(modelValue * 1000);\n          } else {\n            date = new Date(modelValue);\n          }\n          // Setup default value?\n          // if(isNaN(date.getTime())) date = new Date(new Date().setMinutes(0) + 36e5);\n          controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n          return getTimeFormattedString();\n        });\n\n        // viewValue -> element\n        controller.$render = function() {\n          // console.warn('$render(\"%s\"): viewValue=%o', element.attr('ng-model'), controller.$viewValue);\n          element.val(getTimeFormattedString());\n        };\n\n        function getTimeFormattedString() {\n          return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (timepicker) timepicker.destroy();\n          options = null;\n          timepicker = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px'\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // should not parse target attribute, only data-target\n        if(element.attr('data-target')) {\n          options.target = element.attr('data-target');\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.typeahead', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$typeahead', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'typeahead',\n      prefixEvent: '$typeahead',\n      placement: 'bottom-left',\n      template: 'typeahead/typeahead.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      minLength: 1,\n      filter: 'filter',\n      limit: 6,\n      autoSelect: false,\n      comparator: ''\n    };\n\n    this.$get = function($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n\n      function TypeaheadFactory(element, controller, config) {\n\n        var $typeahead = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $typeahead = $tooltip(element, options);\n        var parentScope = config.scope;\n        var scope = $typeahead.$scope;\n\n        scope.$resetMatches = function(){\n          scope.$matches = [];\n          scope.$activeIndex = options.autoSelect ? 0 : -1; // If set to 0, the first match will be highlighted\n        };\n        scope.$resetMatches();\n\n        scope.$activate = function(index) {\n          scope.$$postDigest(function() {\n            $typeahead.activate(index);\n          });\n        };\n\n        scope.$select = function(index, evt) {\n          scope.$$postDigest(function() {\n            $typeahead.select(index);\n          });\n        };\n\n        scope.$isVisible = function() {\n          return $typeahead.$isVisible();\n        };\n\n        // Public methods\n\n        $typeahead.update = function(matches) {\n          scope.$matches = matches;\n          if(scope.$activeIndex >= matches.length) {\n            scope.$activeIndex = options.autoSelect ? 0: -1;\n          }\n          \n          // When the placement is not one of the bottom placements, re-calc the positioning\n          // so the results render correctly.\n          if (/^(bottom|bottom-left|bottom-right)$/.test(options.placement)) return;\n          \n          // wrap in a $timeout so the results are updated\n          // before repositioning\n          $timeout($typeahead.$applyPlacement);\n        };\n\n        $typeahead.activate = function(index) {\n          scope.$activeIndex = index;\n        };\n\n        $typeahead.select = function(index) {\n          var value = scope.$matches[index].value;\n          // console.log('$setViewValue', value);\n          controller.$setViewValue(value);\n          controller.$render();\n          scope.$resetMatches();\n          if(parentScope) parentScope.$digest();\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $typeahead);\n        };\n\n        // Protected methods\n\n        $typeahead.$isVisible = function() {\n          if(!options.minLength || !controller) {\n            return !!scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && angular.isString(controller.$viewValue) && controller.$viewValue.length >= options.minLength;\n        };\n\n        $typeahead.$getIndex = function(value) {\n          var l = scope.$matches.length, i = l;\n          if(!l) return;\n          for(i = l; i--;) {\n            if(scope.$matches[i].value === value) break;\n          }\n          if(i < 0) return;\n          return i;\n        };\n\n        $typeahead.$onMouseDown = function(evt) {\n          // Prevent blur on mousedown\n          evt.preventDefault();\n          evt.stopPropagation();\n        };\n\n        $typeahead.$onKeyDown = function(evt) {\n          if(!/(38|40|13)/.test(evt.keyCode)) return;\n\n          // Let ngSubmit pass if the typeahead tip is hidden\n          if($typeahead.$isVisible()) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // Select with enter\n          if(evt.keyCode === 13 && scope.$matches.length) {\n            $typeahead.select(scope.$activeIndex);\n          }\n\n          // Navigate with keyboard\n          else if(evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n          else if(evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n          else if(angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n          scope.$digest();\n        };\n\n        // Overrides\n\n        var show = $typeahead.show;\n        $typeahead.show = function() {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            $typeahead.$element.on('mousedown', $typeahead.$onMouseDown);\n            if(options.keyboard) {\n              element.on('keydown', $typeahead.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var hide = $typeahead.hide;\n        $typeahead.hide = function() {\n          $typeahead.$element.off('mousedown', $typeahead.$onMouseDown);\n          if(options.keyboard) {\n            element.off('keydown', $typeahead.$onKeyDown);\n          }\n          if(!options.autoSelect)\n            $typeahead.activate(-1);\n          hide();\n        };\n\n        return $typeahead;\n\n      }\n\n      TypeaheadFactory.defaults = defaults;\n      return TypeaheadFactory;\n\n    };\n\n  })\n\n  .directive('bsTypeahead', function($window, $parse, $q, $typeahead, $parseOptions) {\n\n    var defaults = $typeahead.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink(scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'template', 'filter', 'limit', 'minLength', 'watchOptions', 'selectMode', 'autoSelect', 'comparator', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Disable browser autocompletion\n        element.attr('autocomplete' ,'off');\n        \n        // Build proper bsOptions\n        var filter = options.filter || defaults.filter;\n        var limit = options.limit || defaults.limit;\n        var comparator = options.comparator || defaults.comparator;\n\n        var bsOptions = attr.bsOptions;\n        if(filter) bsOptions += ' | ' + filter + ':$viewValue';\n        if (comparator) bsOptions += ':' + comparator;\n        if(limit) bsOptions += ' | limitTo:' + limit;\n        var parsedOptions = $parseOptions(bsOptions);\n\n        // Initialize typeahead\n        var typeahead = $typeahead(element, controller, options);\n\n        // Watch options on demand\n        if(options.watchOptions) {\n          // Watch bsOptions values before filtering for changes, drop function calls\n          var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').replace(/\\(.*\\)/g, '').trim();\n          scope.$watch(watchedOptions, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n            parsedOptions.valuesFn(scope, controller).then(function (values) {\n              typeahead.update(values);\n              controller.$render();\n            });\n          }, true);\n        }\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function(newValue, oldValue) {\n          // console.warn('$watch', element.attr('ng-model'), newValue);\n          scope.$modelValue = newValue; // Publish modelValue on scope for custom templates\n          parsedOptions.valuesFn(scope, controller)\n          .then(function(values) {\n            // Prevent input with no future prospect if selectMode is truthy\n            // @TODO test selectMode\n            if(options.selectMode && !values.length && newValue.length > 0) {\n              controller.$setViewValue(controller.$viewValue.substring(0, controller.$viewValue.length - 1));\n              return;\n            }\n            if(values.length > limit) values = values.slice(0, limit);\n            var isVisible = typeahead.$isVisible();\n            isVisible && typeahead.update(values);\n            // Do not re-queue an update if a correct value has been selected\n            if(values.length === 1 && values[0].value === newValue) return;\n            !isVisible && typeahead.update(values);\n            // Queue a new rendering that will leverage collection loading\n            controller.$render();\n          });\n        });\n\n        // modelValue -> $formatters -> viewValue\n        controller.$formatters.push(function(modelValue) {\n          // console.warn('$formatter(\"%s\"): modelValue=%o (%o)', element.attr('ng-model'), modelValue, typeof modelValue);\n          var displayValue = parsedOptions.displayValue(modelValue);\n          return displayValue === undefined ? '' : displayValue;\n        });\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          if(controller.$isEmpty(controller.$viewValue)) return element.val('');\n          var index = typeahead.$getIndex(controller.$modelValue);\n          var selected = angular.isDefined(index) ? typeahead.$scope.$matches[index].label : controller.$viewValue;\n          selected = angular.isObject(selected) ? parsedOptions.displayValue(selected) : selected;\n          element.val(selected ? selected.toString().replace(/<(?:.|\\n)*?>/gm, '').trim() : '');\n        };\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (typeahead) typeahead.destroy();\n          options = null;\n          typeahead = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}