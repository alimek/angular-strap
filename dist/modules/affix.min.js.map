{"version":3,"sources":["affix.min.js","affix/affix.js"],"names":["angular","module","provider","defaults","this","offsetTop","inlineStyles","$get","$window","debounce","dimensions","AffixFactory","element","config","getRequiredAffixClass","unpin","position","elementHeight","scrollTop","getScrollTop","scrollHeight","getScrollHeight","top","offsetBottom","initialAffixTop","targetEl","pageYOffset","document","body","$affix","options","extend","target","reset","setWidth","initialOffsetTop","affixed","parent","offsetParent","match","i","init","$parseOffsets","offset","style","width","on","checkPosition","checkPositionWithEventLoop","windowEl","$debouncedOnResize","destroy","off","setTimeout","height","affix","removeClass","addClass","css","offsetUnpin","bodyEl","offsetHeight","offsetWidth","$onResize","initialPosition","directive","restrict","require","link","scope","attr","affixTarget","$element","forEach","key","isDefined","option","test","$on","controller"],"mappings":"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","file":"affix.min.js","sourcesContent":[null,"'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          this.$parseOffsets();\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n"],"sourceRoot":"/source/"}